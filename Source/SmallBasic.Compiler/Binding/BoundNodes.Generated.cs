// <copyright file="BoundNodes.Generated.cs" company="MIT License">
// Licensed under the MIT License. See LICENSE file in the project root for license information.
// </copyright>

/// <summary>
/// This file is auto-generated by a build task. It shouldn't be edited by hand.
/// </summary>
namespace SmallBasic.Compiler.Binding
{
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using SmallBasic.Compiler.Parsing;
    using SmallBasic.Compiler.Scanning;
    using SmallBasic.Utilities;

    public abstract class BaseBoundNodeVisitor
    {
        private protected void Visit(BaseBoundNode node)
        {
            switch (node)
            {
                case BoundSubModule subModule:
                    this.VisitSubModule(subModule);
                    break;
                case BoundStatementBlock statementBlock:
                    this.VisitStatementBlock(statementBlock);
                    break;
                case BoundIfPart ifPart:
                    this.VisitIfPart(ifPart);
                    break;
                case BoundElseIfPart elseIfPart:
                    this.VisitElseIfPart(elseIfPart);
                    break;
                case BoundElsePart elsePart:
                    this.VisitElsePart(elsePart);
                    break;
                case BoundIfStatement ifStatement:
                    this.VisitIfStatement(ifStatement);
                    break;
                case BoundWhileStatement whileStatement:
                    this.VisitWhileStatement(whileStatement);
                    break;
                case BoundForStatement forStatement:
                    this.VisitForStatement(forStatement);
                    break;
                case BoundLabelStatement labelStatement:
                    this.VisitLabelStatement(labelStatement);
                    break;
                case BoundGoToStatement goToStatement:
                    this.VisitGoToStatement(goToStatement);
                    break;
                case BoundSubModuleInvocationStatement subModuleInvocationStatement:
                    this.VisitSubModuleInvocationStatement(subModuleInvocationStatement);
                    break;
                case BoundLibraryMethodInvocationStatement libraryMethodInvocationStatement:
                    this.VisitLibraryMethodInvocationStatement(libraryMethodInvocationStatement);
                    break;
                case BoundVariableAssignmentStatement variableAssignmentStatement:
                    this.VisitVariableAssignmentStatement(variableAssignmentStatement);
                    break;
                case BoundPropertyAssignmentStatement propertyAssignmentStatement:
                    this.VisitPropertyAssignmentStatement(propertyAssignmentStatement);
                    break;
                case BoundEventAssignmentStatement eventAssignmentStatement:
                    this.VisitEventAssignmentStatement(eventAssignmentStatement);
                    break;
                case BoundArrayAssignmentStatement arrayAssignmentStatement:
                    this.VisitArrayAssignmentStatement(arrayAssignmentStatement);
                    break;
                case BoundInvalidExpressionStatement invalidExpressionStatement:
                    this.VisitInvalidExpressionStatement(invalidExpressionStatement);
                    break;
                case BoundUnaryExpression unaryExpression:
                    this.VisitUnaryExpression(unaryExpression);
                    break;
                case BoundBinaryExpression binaryExpression:
                    this.VisitBinaryExpression(binaryExpression);
                    break;
                case BoundArrayAccessExpression arrayAccessExpression:
                    this.VisitArrayAccessExpression(arrayAccessExpression);
                    break;
                case BoundLibraryTypeExpression libraryTypeExpression:
                    this.VisitLibraryTypeExpression(libraryTypeExpression);
                    break;
                case BoundLibraryMethodExpression libraryMethodExpression:
                    this.VisitLibraryMethodExpression(libraryMethodExpression);
                    break;
                case BoundLibraryPropertyExpression libraryPropertyExpression:
                    this.VisitLibraryPropertyExpression(libraryPropertyExpression);
                    break;
                case BoundLibraryEventExpression libraryEventExpression:
                    this.VisitLibraryEventExpression(libraryEventExpression);
                    break;
                case BoundLibraryMethodInvocationExpression libraryMethodInvocationExpression:
                    this.VisitLibraryMethodInvocationExpression(libraryMethodInvocationExpression);
                    break;
                case BoundSubModuleExpression subModuleExpression:
                    this.VisitSubModuleExpression(subModuleExpression);
                    break;
                case BoundSubModuleInvocationExpression subModuleInvocationExpression:
                    this.VisitSubModuleInvocationExpression(subModuleInvocationExpression);
                    break;
                case BoundVariableExpression variableExpression:
                    this.VisitVariableExpression(variableExpression);
                    break;
                case BoundStringLiteralExpression stringLiteralExpression:
                    this.VisitStringLiteralExpression(stringLiteralExpression);
                    break;
                case BoundNumberLiteralExpression numberLiteralExpression:
                    this.VisitNumberLiteralExpression(numberLiteralExpression);
                    break;
                case BoundParenthesisExpression parenthesisExpression:
                    this.VisitParenthesisExpression(parenthesisExpression);
                    break;
                case BoundInvalidExpression invalidExpression:
                    this.VisitInvalidExpression(invalidExpression);
                    break;
                default:
                    throw ExceptionUtilities.UnexpectedValue(node);
            }
        }

        private protected virtual void VisitSubModule(BoundSubModule node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitStatementBlock(BoundStatementBlock node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitIfPart(BoundIfPart node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitElseIfPart(BoundElseIfPart node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitElsePart(BoundElsePart node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitIfStatement(BoundIfStatement node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitWhileStatement(BoundWhileStatement node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitForStatement(BoundForStatement node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitLabelStatement(BoundLabelStatement node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitGoToStatement(BoundGoToStatement node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitSubModuleInvocationStatement(BoundSubModuleInvocationStatement node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitLibraryMethodInvocationStatement(BoundLibraryMethodInvocationStatement node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitVariableAssignmentStatement(BoundVariableAssignmentStatement node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitPropertyAssignmentStatement(BoundPropertyAssignmentStatement node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitEventAssignmentStatement(BoundEventAssignmentStatement node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitArrayAssignmentStatement(BoundArrayAssignmentStatement node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitInvalidExpressionStatement(BoundInvalidExpressionStatement node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitUnaryExpression(BoundUnaryExpression node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitBinaryExpression(BoundBinaryExpression node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitArrayAccessExpression(BoundArrayAccessExpression node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitLibraryTypeExpression(BoundLibraryTypeExpression node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitLibraryMethodExpression(BoundLibraryMethodExpression node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitLibraryPropertyExpression(BoundLibraryPropertyExpression node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitLibraryEventExpression(BoundLibraryEventExpression node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitLibraryMethodInvocationExpression(BoundLibraryMethodInvocationExpression node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitSubModuleExpression(BoundSubModuleExpression node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitSubModuleInvocationExpression(BoundSubModuleInvocationExpression node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitVariableExpression(BoundVariableExpression node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitStringLiteralExpression(BoundStringLiteralExpression node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitNumberLiteralExpression(BoundNumberLiteralExpression node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitParenthesisExpression(BoundParenthesisExpression node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitInvalidExpression(BoundInvalidExpression node)
        {
            this.DefaultVisit(node);
        }

        private void DefaultVisit(BaseBoundNode node)
        {
            foreach (var child in node.Children)
            {
                this.Visit(child);
            }
        }
    }

    internal sealed class BoundSubModule : BaseBoundNode
    {
        public BoundSubModule(SubModuleStatementSyntax syntax, string name, BoundStatementBlock body)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!name.IsDefault(), "'name' must not be null.");
            Debug.Assert(!body.IsDefault(), "'body' must not be null.");

            this.Syntax = syntax;
            this.Name = name;
            this.Body = body;
        }

        public SubModuleStatementSyntax Syntax { get; private set; }

        public string Name { get; private set; }

        public BoundStatementBlock Body { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Body;
            }
        }
    }

    internal abstract class BaseBoundStatement : BaseBoundNode
    {
    }

    internal sealed class BoundStatementBlock : BaseBoundStatement
    {
        public BoundStatementBlock(StatementBlockSyntax syntax, IReadOnlyList<BaseBoundStatement> body)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!body.IsDefault(), "'body' must not be null.");

            this.Syntax = syntax;
            this.Body = body;
        }

        public StatementBlockSyntax Syntax { get; private set; }

        public IReadOnlyList<BaseBoundStatement> Body { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                foreach (var child in this.Body)
                {
                    yield return child;
                }
            }
        }
    }

    internal sealed class BoundIfPart : BaseBoundNode
    {
        public BoundIfPart(IfPartSyntax syntax, BaseBoundExpression condition, BoundStatementBlock body)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!condition.IsDefault(), "'condition' must not be null.");
            Debug.Assert(!body.IsDefault(), "'body' must not be null.");

            this.Syntax = syntax;
            this.Condition = condition;
            this.Body = body;
        }

        public IfPartSyntax Syntax { get; private set; }

        public BaseBoundExpression Condition { get; private set; }

        public BoundStatementBlock Body { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Condition;
                yield return this.Body;
            }
        }
    }

    internal sealed class BoundElseIfPart : BaseBoundNode
    {
        public BoundElseIfPart(ElseIfPartSyntax syntax, BaseBoundExpression condition, BoundStatementBlock body)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!condition.IsDefault(), "'condition' must not be null.");
            Debug.Assert(!body.IsDefault(), "'body' must not be null.");

            this.Syntax = syntax;
            this.Condition = condition;
            this.Body = body;
        }

        public ElseIfPartSyntax Syntax { get; private set; }

        public BaseBoundExpression Condition { get; private set; }

        public BoundStatementBlock Body { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Condition;
                yield return this.Body;
            }
        }
    }

    internal sealed class BoundElsePart : BaseBoundNode
    {
        public BoundElsePart(ElsePartSyntax syntax, BoundStatementBlock body)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!body.IsDefault(), "'body' must not be null.");

            this.Syntax = syntax;
            this.Body = body;
        }

        public ElsePartSyntax Syntax { get; private set; }

        public BoundStatementBlock Body { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Body;
            }
        }
    }

    internal sealed class BoundIfStatement : BaseBoundStatement
    {
        public BoundIfStatement(IfStatementSyntax syntax, BoundIfPart ifPart, IReadOnlyList<BoundElseIfPart> elseIfParts, BoundElsePart elsePartOpt)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!ifPart.IsDefault(), "'ifPart' must not be null.");
            Debug.Assert(!elseIfParts.IsDefault(), "'elseIfParts' must not be null.");

            this.Syntax = syntax;
            this.IfPart = ifPart;
            this.ElseIfParts = elseIfParts;
            this.ElsePartOpt = elsePartOpt;
        }

        public IfStatementSyntax Syntax { get; private set; }

        public BoundIfPart IfPart { get; private set; }

        public IReadOnlyList<BoundElseIfPart> ElseIfParts { get; private set; }

        public BoundElsePart ElsePartOpt { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.IfPart;
                foreach (var child in this.ElseIfParts)
                {
                    yield return child;
                }

                if (!this.ElsePartOpt.IsDefault())
                {
                    yield return this.ElsePartOpt;
                }
            }
        }
    }

    internal sealed class BoundWhileStatement : BaseBoundStatement
    {
        public BoundWhileStatement(WhileStatementSyntax syntax, BaseBoundExpression condition, BoundStatementBlock body)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!condition.IsDefault(), "'condition' must not be null.");
            Debug.Assert(!body.IsDefault(), "'body' must not be null.");

            this.Syntax = syntax;
            this.Condition = condition;
            this.Body = body;
        }

        public WhileStatementSyntax Syntax { get; private set; }

        public BaseBoundExpression Condition { get; private set; }

        public BoundStatementBlock Body { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Condition;
                yield return this.Body;
            }
        }
    }

    internal sealed class BoundForStatement : BaseBoundStatement
    {
        public BoundForStatement(ForStatementSyntax syntax, string identifier, BaseBoundExpression fromExpression, BaseBoundExpression toExpression, BaseBoundExpression stepExpressionOpt, BoundStatementBlock body)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!identifier.IsDefault(), "'identifier' must not be null.");
            Debug.Assert(!fromExpression.IsDefault(), "'fromExpression' must not be null.");
            Debug.Assert(!toExpression.IsDefault(), "'toExpression' must not be null.");
            Debug.Assert(!body.IsDefault(), "'body' must not be null.");

            this.Syntax = syntax;
            this.Identifier = identifier;
            this.FromExpression = fromExpression;
            this.ToExpression = toExpression;
            this.StepExpressionOpt = stepExpressionOpt;
            this.Body = body;
        }

        public ForStatementSyntax Syntax { get; private set; }

        public string Identifier { get; private set; }

        public BaseBoundExpression FromExpression { get; private set; }

        public BaseBoundExpression ToExpression { get; private set; }

        public BaseBoundExpression StepExpressionOpt { get; private set; }

        public BoundStatementBlock Body { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.FromExpression;
                yield return this.ToExpression;
                if (!this.StepExpressionOpt.IsDefault())
                {
                    yield return this.StepExpressionOpt;
                }

                yield return this.Body;
            }
        }
    }

    internal sealed class BoundLabelStatement : BaseBoundStatement
    {
        public BoundLabelStatement(LabelStatementSyntax syntax, string label)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!label.IsDefault(), "'label' must not be null.");

            this.Syntax = syntax;
            this.Label = label;
        }

        public LabelStatementSyntax Syntax { get; private set; }

        public string Label { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundGoToStatement : BaseBoundStatement
    {
        public BoundGoToStatement(GoToStatementSyntax syntax, string label)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!label.IsDefault(), "'label' must not be null.");

            this.Syntax = syntax;
            this.Label = label;
        }

        public GoToStatementSyntax Syntax { get; private set; }

        public string Label { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundSubModuleInvocationStatement : BaseBoundStatement
    {
        public BoundSubModuleInvocationStatement(ExpressionStatementSyntax syntax, BoundSubModuleInvocationExpression expression)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!expression.IsDefault(), "'expression' must not be null.");

            this.Syntax = syntax;
            this.Expression = expression;
        }

        public ExpressionStatementSyntax Syntax { get; private set; }

        public BoundSubModuleInvocationExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }
    }

    internal sealed class BoundLibraryMethodInvocationStatement : BaseBoundStatement
    {
        public BoundLibraryMethodInvocationStatement(ExpressionStatementSyntax syntax, BoundLibraryMethodInvocationExpression expression)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!expression.IsDefault(), "'expression' must not be null.");

            this.Syntax = syntax;
            this.Expression = expression;
        }

        public ExpressionStatementSyntax Syntax { get; private set; }

        public BoundLibraryMethodInvocationExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }
    }

    internal sealed class BoundVariableAssignmentStatement : BaseBoundStatement
    {
        public BoundVariableAssignmentStatement(ExpressionStatementSyntax syntax, BoundVariableExpression variable, BaseBoundExpression expression)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!variable.IsDefault(), "'variable' must not be null.");
            Debug.Assert(!expression.IsDefault(), "'expression' must not be null.");

            this.Syntax = syntax;
            this.Variable = variable;
            this.Expression = expression;
        }

        public ExpressionStatementSyntax Syntax { get; private set; }

        public BoundVariableExpression Variable { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Variable;
                yield return this.Expression;
            }
        }
    }

    internal sealed class BoundPropertyAssignmentStatement : BaseBoundStatement
    {
        public BoundPropertyAssignmentStatement(ExpressionStatementSyntax syntax, BoundLibraryPropertyExpression property, BaseBoundExpression expression)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!property.IsDefault(), "'property' must not be null.");
            Debug.Assert(!expression.IsDefault(), "'expression' must not be null.");

            this.Syntax = syntax;
            this.Property = property;
            this.Expression = expression;
        }

        public ExpressionStatementSyntax Syntax { get; private set; }

        public BoundLibraryPropertyExpression Property { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Property;
                yield return this.Expression;
            }
        }
    }

    internal sealed class BoundEventAssignmentStatement : BaseBoundStatement
    {
        public BoundEventAssignmentStatement(ExpressionStatementSyntax syntax, BoundLibraryEventExpression usedEvent, string subModule)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!usedEvent.IsDefault(), "'usedEvent' must not be null.");
            Debug.Assert(!subModule.IsDefault(), "'subModule' must not be null.");

            this.Syntax = syntax;
            this.UsedEvent = usedEvent;
            this.SubModule = subModule;
        }

        public ExpressionStatementSyntax Syntax { get; private set; }

        public BoundLibraryEventExpression UsedEvent { get; private set; }

        public string SubModule { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.UsedEvent;
            }
        }
    }

    internal sealed class BoundArrayAssignmentStatement : BaseBoundStatement
    {
        public BoundArrayAssignmentStatement(ExpressionStatementSyntax syntax, BoundArrayAccessExpression array, BaseBoundExpression expression)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!array.IsDefault(), "'array' must not be null.");
            Debug.Assert(!expression.IsDefault(), "'expression' must not be null.");

            this.Syntax = syntax;
            this.Array = array;
            this.Expression = expression;
        }

        public ExpressionStatementSyntax Syntax { get; private set; }

        public BoundArrayAccessExpression Array { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Array;
                yield return this.Expression;
            }
        }
    }

    internal sealed class BoundInvalidExpressionStatement : BaseBoundStatement
    {
        public BoundInvalidExpressionStatement(ExpressionStatementSyntax syntax, BaseBoundExpression expression)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!expression.IsDefault(), "'expression' must not be null.");

            this.Syntax = syntax;
            this.Expression = expression;
        }

        public ExpressionStatementSyntax Syntax { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }
    }

    internal abstract class BaseBoundExpression : BaseBoundNode
    {
        public BaseBoundExpression(bool hasValue, bool hasErrors)
        {
            Debug.Assert(!hasValue.IsDefault(), "'hasValue' must not be null.");
            Debug.Assert(!hasErrors.IsDefault(), "'hasErrors' must not be null.");

            this.HasValue = hasValue;
            this.HasErrors = hasErrors;
        }

        public bool HasValue { get; private set; }

        public bool HasErrors { get; private set; }
    }

    internal sealed class BoundUnaryExpression : BaseBoundExpression
    {
        public BoundUnaryExpression(UnaryOperatorExpressionSyntax syntax, bool hasValue, bool hasErrors, TokenKind kind, BaseBoundExpression expression)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!kind.IsDefault(), "'kind' must not be null.");
            Debug.Assert(!expression.IsDefault(), "'expression' must not be null.");

            this.Syntax = syntax;
            this.Kind = kind;
            this.Expression = expression;
        }

        public UnaryOperatorExpressionSyntax Syntax { get; private set; }

        public TokenKind Kind { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }
    }

    internal sealed class BoundBinaryExpression : BaseBoundExpression
    {
        public BoundBinaryExpression(BinaryOperatorExpressionSyntax syntax, bool hasValue, bool hasErrors, TokenKind kind, BaseBoundExpression left, BaseBoundExpression right)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!kind.IsDefault(), "'kind' must not be null.");
            Debug.Assert(!left.IsDefault(), "'left' must not be null.");
            Debug.Assert(!right.IsDefault(), "'right' must not be null.");

            this.Syntax = syntax;
            this.Kind = kind;
            this.Left = left;
            this.Right = right;
        }

        public BinaryOperatorExpressionSyntax Syntax { get; private set; }

        public TokenKind Kind { get; private set; }

        public BaseBoundExpression Left { get; private set; }

        public BaseBoundExpression Right { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Left;
                yield return this.Right;
            }
        }
    }

    internal sealed class BoundArrayAccessExpression : BaseBoundExpression
    {
        public BoundArrayAccessExpression(ArrayAccessExpressionSyntax syntax, bool hasValue, bool hasErrors, string name, IReadOnlyList<BaseBoundExpression> indices)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!name.IsDefault(), "'name' must not be null.");
            Debug.Assert(!indices.IsDefault(), "'indices' must not be null.");

            this.Syntax = syntax;
            this.Name = name;
            this.Indices = indices;
        }

        public ArrayAccessExpressionSyntax Syntax { get; private set; }

        public string Name { get; private set; }

        public IReadOnlyList<BaseBoundExpression> Indices { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                foreach (var child in this.Indices)
                {
                    yield return child;
                }
            }
        }
    }

    internal sealed class BoundLibraryTypeExpression : BaseBoundExpression
    {
        public BoundLibraryTypeExpression(IdentifierExpressionSyntax syntax, bool hasValue, bool hasErrors, string name)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!name.IsDefault(), "'name' must not be null.");

            this.Syntax = syntax;
            this.Name = name;
        }

        public IdentifierExpressionSyntax Syntax { get; private set; }

        public string Name { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundLibraryMethodExpression : BaseBoundExpression
    {
        public BoundLibraryMethodExpression(ObjectAccessExpressionSyntax syntax, bool hasValue, bool hasErrors, BoundLibraryTypeExpression library, string name)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!library.IsDefault(), "'library' must not be null.");
            Debug.Assert(!name.IsDefault(), "'name' must not be null.");

            this.Syntax = syntax;
            this.Library = library;
            this.Name = name;
        }

        public ObjectAccessExpressionSyntax Syntax { get; private set; }

        public BoundLibraryTypeExpression Library { get; private set; }

        public string Name { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Library;
            }
        }
    }

    internal sealed class BoundLibraryPropertyExpression : BaseBoundExpression
    {
        public BoundLibraryPropertyExpression(ObjectAccessExpressionSyntax syntax, bool hasValue, bool hasErrors, BoundLibraryTypeExpression library, string name)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!library.IsDefault(), "'library' must not be null.");
            Debug.Assert(!name.IsDefault(), "'name' must not be null.");

            this.Syntax = syntax;
            this.Library = library;
            this.Name = name;
        }

        public ObjectAccessExpressionSyntax Syntax { get; private set; }

        public BoundLibraryTypeExpression Library { get; private set; }

        public string Name { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Library;
            }
        }
    }

    internal sealed class BoundLibraryEventExpression : BaseBoundExpression
    {
        public BoundLibraryEventExpression(ObjectAccessExpressionSyntax syntax, bool hasValue, bool hasErrors, BoundLibraryTypeExpression library, string name)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!library.IsDefault(), "'library' must not be null.");
            Debug.Assert(!name.IsDefault(), "'name' must not be null.");

            this.Syntax = syntax;
            this.Library = library;
            this.Name = name;
        }

        public ObjectAccessExpressionSyntax Syntax { get; private set; }

        public BoundLibraryTypeExpression Library { get; private set; }

        public string Name { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Library;
            }
        }
    }

    internal sealed class BoundLibraryMethodInvocationExpression : BaseBoundExpression
    {
        public BoundLibraryMethodInvocationExpression(InvocationExpressionSyntax syntax, bool hasValue, bool hasErrors, BoundLibraryMethodExpression method, IReadOnlyList<BaseBoundExpression> arguments)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!method.IsDefault(), "'method' must not be null.");
            Debug.Assert(!arguments.IsDefault(), "'arguments' must not be null.");

            this.Syntax = syntax;
            this.Method = method;
            this.Arguments = arguments;
        }

        public InvocationExpressionSyntax Syntax { get; private set; }

        public BoundLibraryMethodExpression Method { get; private set; }

        public IReadOnlyList<BaseBoundExpression> Arguments { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Method;
                foreach (var child in this.Arguments)
                {
                    yield return child;
                }
            }
        }
    }

    internal sealed class BoundSubModuleExpression : BaseBoundExpression
    {
        public BoundSubModuleExpression(IdentifierExpressionSyntax syntax, bool hasValue, bool hasErrors, string name)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!name.IsDefault(), "'name' must not be null.");

            this.Syntax = syntax;
            this.Name = name;
        }

        public IdentifierExpressionSyntax Syntax { get; private set; }

        public string Name { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundSubModuleInvocationExpression : BaseBoundExpression
    {
        public BoundSubModuleInvocationExpression(InvocationExpressionSyntax syntax, bool hasValue, bool hasErrors, string name)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!name.IsDefault(), "'name' must not be null.");

            this.Syntax = syntax;
            this.Name = name;
        }

        public InvocationExpressionSyntax Syntax { get; private set; }

        public string Name { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundVariableExpression : BaseBoundExpression
    {
        public BoundVariableExpression(IdentifierExpressionSyntax syntax, bool hasValue, bool hasErrors, string name)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!name.IsDefault(), "'name' must not be null.");

            this.Syntax = syntax;
            this.Name = name;
        }

        public IdentifierExpressionSyntax Syntax { get; private set; }

        public string Name { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundStringLiteralExpression : BaseBoundExpression
    {
        public BoundStringLiteralExpression(StringLiteralExpressionSyntax syntax, bool hasValue, bool hasErrors, string value)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!value.IsDefault(), "'value' must not be null.");

            this.Syntax = syntax;
            this.Value = value;
        }

        public StringLiteralExpressionSyntax Syntax { get; private set; }

        public string Value { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundNumberLiteralExpression : BaseBoundExpression
    {
        public BoundNumberLiteralExpression(NumberLiteralExpressionSyntax syntax, bool hasValue, bool hasErrors, decimal value)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!value.IsDefault(), "'value' must not be null.");

            this.Syntax = syntax;
            this.Value = value;
        }

        public NumberLiteralExpressionSyntax Syntax { get; private set; }

        public decimal Value { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundParenthesisExpression : BaseBoundExpression
    {
        public BoundParenthesisExpression(ParenthesisExpressionSyntax syntax, bool hasValue, bool hasErrors, BaseBoundExpression expression)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");
            Debug.Assert(!expression.IsDefault(), "'expression' must not be null.");

            this.Syntax = syntax;
            this.Expression = expression;
        }

        public ParenthesisExpressionSyntax Syntax { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }
    }

    internal sealed class BoundInvalidExpression : BaseBoundExpression
    {
        public BoundInvalidExpression(BaseExpressionSyntax syntax, bool hasValue, bool hasErrors)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!syntax.IsDefault(), "'syntax' must not be null.");

            this.Syntax = syntax;
        }

        public BaseExpressionSyntax Syntax { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }
}
