// <copyright file="SyntaxNodes.Generated.cs" company="MIT License">
// Licensed under the MIT License. See LICENSE file in the project root for license information.
// </copyright>

/// <summary>
/// This file is auto-generated by a build task. It shouldn't be edited by hand.
/// </summary>
namespace SmallBasic.Compiler.Parsing
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using SmallBasic.Compiler.Scanning;
    using SmallBasic.Utilities;

    public abstract class BaseSyntaxNodeVisitor
    {
        private protected void Visit(BaseSyntaxNode node)
        {
            switch (node)
            {
                case SubModuleStatementSyntax subModuleStatement:
                    this.VisitSubModuleStatement(subModuleStatement);
                    break;
                case StatementBlockSyntax statementBlock:
                    this.VisitStatementBlock(statementBlock);
                    break;
                case IfPartSyntax ifPart:
                    this.VisitIfPart(ifPart);
                    break;
                case ElseIfPartSyntax elseIfPart:
                    this.VisitElseIfPart(elseIfPart);
                    break;
                case ElsePartSyntax elsePart:
                    this.VisitElsePart(elsePart);
                    break;
                case IfStatementSyntax ifStatement:
                    this.VisitIfStatement(ifStatement);
                    break;
                case WhileStatementSyntax whileStatement:
                    this.VisitWhileStatement(whileStatement);
                    break;
                case ForStepClauseSyntax forStepClause:
                    this.VisitForStepClause(forStepClause);
                    break;
                case ForStatementSyntax forStatement:
                    this.VisitForStatement(forStatement);
                    break;
                case LabelStatementSyntax labelStatement:
                    this.VisitLabelStatement(labelStatement);
                    break;
                case GoToStatementSyntax goToStatement:
                    this.VisitGoToStatement(goToStatement);
                    break;
                case UnrecognizedStatementSyntax unrecognizedStatement:
                    this.VisitUnrecognizedStatement(unrecognizedStatement);
                    break;
                case ExpressionStatementSyntax expressionStatement:
                    this.VisitExpressionStatement(expressionStatement);
                    break;
                case CommentStatementSyntax commentStatement:
                    this.VisitCommentStatement(commentStatement);
                    break;
                case UnaryOperatorExpressionSyntax unaryOperatorExpression:
                    this.VisitUnaryOperatorExpression(unaryOperatorExpression);
                    break;
                case BinaryOperatorExpressionSyntax binaryOperatorExpression:
                    this.VisitBinaryOperatorExpression(binaryOperatorExpression);
                    break;
                case ObjectAccessExpressionSyntax objectAccessExpression:
                    this.VisitObjectAccessExpression(objectAccessExpression);
                    break;
                case ArrayAccessExpressionSyntax arrayAccessExpression:
                    this.VisitArrayAccessExpression(arrayAccessExpression);
                    break;
                case ArgumentSyntax argument:
                    this.VisitArgument(argument);
                    break;
                case InvocationExpressionSyntax invocationExpression:
                    this.VisitInvocationExpression(invocationExpression);
                    break;
                case ParenthesisExpressionSyntax parenthesisExpression:
                    this.VisitParenthesisExpression(parenthesisExpression);
                    break;
                case IdentifierExpressionSyntax identifierExpression:
                    this.VisitIdentifierExpression(identifierExpression);
                    break;
                case StringLiteralExpressionSyntax stringLiteralExpression:
                    this.VisitStringLiteralExpression(stringLiteralExpression);
                    break;
                case NumberLiteralExpressionSyntax numberLiteralExpression:
                    this.VisitNumberLiteralExpression(numberLiteralExpression);
                    break;
                case UnrecognizedExpressionSyntax unrecognizedExpression:
                    this.VisitUnrecognizedExpression(unrecognizedExpression);
                    break;
                default:
                    throw ExceptionUtilities.UnexpectedValue(node);
            }
        }

        private protected virtual void VisitSubModuleStatement(SubModuleStatementSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitStatementBlock(StatementBlockSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitIfPart(IfPartSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitElseIfPart(ElseIfPartSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitElsePart(ElsePartSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitIfStatement(IfStatementSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitWhileStatement(WhileStatementSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitForStepClause(ForStepClauseSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitForStatement(ForStatementSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitLabelStatement(LabelStatementSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitGoToStatement(GoToStatementSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitUnrecognizedStatement(UnrecognizedStatementSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitExpressionStatement(ExpressionStatementSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitCommentStatement(CommentStatementSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitUnaryOperatorExpression(UnaryOperatorExpressionSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitBinaryOperatorExpression(BinaryOperatorExpressionSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitObjectAccessExpression(ObjectAccessExpressionSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitArrayAccessExpression(ArrayAccessExpressionSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitArgument(ArgumentSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitInvocationExpression(InvocationExpressionSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitParenthesisExpression(ParenthesisExpressionSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitIdentifierExpression(IdentifierExpressionSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitStringLiteralExpression(StringLiteralExpressionSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitNumberLiteralExpression(NumberLiteralExpressionSyntax node)
        {
            this.DefaultVisit(node);
        }

        private protected virtual void VisitUnrecognizedExpression(UnrecognizedExpressionSyntax node)
        {
            this.DefaultVisit(node);
        }

        private void DefaultVisit(BaseSyntaxNode node)
        {
            foreach (var child in node.Children)
            {
                this.Visit(child);
            }
        }
    }

    internal abstract class BaseStatementSyntax : BaseSyntaxNode
    {
    }

    internal sealed class SubModuleStatementSyntax : BaseStatementSyntax
    {
        public SubModuleStatementSyntax(Token subToken, Token nameToken, StatementBlockSyntax body, Token endSubToken)
        {
            Debug.Assert(!subToken.IsDefault(), "'subToken' must not be null.");
            Debug.Assert(subToken.Kind == TokenKind.Sub, "'subToken' must have a TokenKind of 'Sub'.");
            Debug.Assert(!nameToken.IsDefault(), "'nameToken' must not be null.");
            Debug.Assert(nameToken.Kind == TokenKind.Identifier, "'nameToken' must have a TokenKind of 'Identifier'.");
            Debug.Assert(!body.IsDefault(), "'body' must not be null.");
            Debug.Assert(!endSubToken.IsDefault(), "'endSubToken' must not be null.");
            Debug.Assert(endSubToken.Kind == TokenKind.EndSub, "'endSubToken' must have a TokenKind of 'EndSub'.");

            this.SubToken = subToken;
            this.NameToken = nameToken;
            this.Body = body;
            this.Body.Parent = this;
            this.EndSubToken = endSubToken;
        }

        public Token SubToken { get; private set; }

        public Token NameToken { get; private set; }

        public StatementBlockSyntax Body { get; private set; }

        public Token EndSubToken { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                yield return this.Body;
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.SubToken.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.EndSubToken.Range.End;
                }
            }
        }
    }

    internal sealed class StatementBlockSyntax : BaseStatementSyntax
    {
        public StatementBlockSyntax(IReadOnlyList<BaseStatementSyntax> body)
        {
            Debug.Assert(!body.IsDefault(), "'body' must not be null.");

            this.Body = body;
            foreach (var child in this.Body)
            {
                child.Parent = this;
            }
        }

        public IReadOnlyList<BaseStatementSyntax> Body { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                foreach (var child in this.Body)
                {
                    yield return child;
                }
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    var bodyChild = this.Body.FirstOrDefault();
                    if (!bodyChild.IsDefault())
                    {
                        return bodyChild.Range.Start;
                    }

                    return (0, 0);
                }

                TextPosition calculateEnd()
                {
                    var bodyChild = this.Body.LastOrDefault();
                    if (!bodyChild.IsDefault())
                    {
                        return bodyChild.Range.End;
                    }

                    return (0, 0);
                }
            }
        }
    }

    internal sealed class IfPartSyntax : BaseSyntaxNode
    {
        public IfPartSyntax(Token ifToken, BaseExpressionSyntax condition, Token thenToken, StatementBlockSyntax body)
        {
            Debug.Assert(!ifToken.IsDefault(), "'ifToken' must not be null.");
            Debug.Assert(ifToken.Kind == TokenKind.If, "'ifToken' must have a TokenKind of 'If'.");
            Debug.Assert(!condition.IsDefault(), "'condition' must not be null.");
            Debug.Assert(!thenToken.IsDefault(), "'thenToken' must not be null.");
            Debug.Assert(thenToken.Kind == TokenKind.Then, "'thenToken' must have a TokenKind of 'Then'.");
            Debug.Assert(!body.IsDefault(), "'body' must not be null.");

            this.IfToken = ifToken;
            this.Condition = condition;
            this.Condition.Parent = this;
            this.ThenToken = thenToken;
            this.Body = body;
            this.Body.Parent = this;
        }

        public Token IfToken { get; private set; }

        public BaseExpressionSyntax Condition { get; private set; }

        public Token ThenToken { get; private set; }

        public StatementBlockSyntax Body { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                yield return this.Condition;
                yield return this.Body;
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.IfToken.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.Body.Range.End;
                }
            }
        }
    }

    internal sealed class ElseIfPartSyntax : BaseSyntaxNode
    {
        public ElseIfPartSyntax(Token elseIfToken, BaseExpressionSyntax condition, Token thenToken, StatementBlockSyntax body)
        {
            Debug.Assert(!elseIfToken.IsDefault(), "'elseIfToken' must not be null.");
            Debug.Assert(elseIfToken.Kind == TokenKind.ElseIf, "'elseIfToken' must have a TokenKind of 'ElseIf'.");
            Debug.Assert(!condition.IsDefault(), "'condition' must not be null.");
            Debug.Assert(!thenToken.IsDefault(), "'thenToken' must not be null.");
            Debug.Assert(thenToken.Kind == TokenKind.Then, "'thenToken' must have a TokenKind of 'Then'.");
            Debug.Assert(!body.IsDefault(), "'body' must not be null.");

            this.ElseIfToken = elseIfToken;
            this.Condition = condition;
            this.Condition.Parent = this;
            this.ThenToken = thenToken;
            this.Body = body;
            this.Body.Parent = this;
        }

        public Token ElseIfToken { get; private set; }

        public BaseExpressionSyntax Condition { get; private set; }

        public Token ThenToken { get; private set; }

        public StatementBlockSyntax Body { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                yield return this.Condition;
                yield return this.Body;
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.ElseIfToken.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.Body.Range.End;
                }
            }
        }
    }

    internal sealed class ElsePartSyntax : BaseSyntaxNode
    {
        public ElsePartSyntax(Token elseToken, StatementBlockSyntax body)
        {
            Debug.Assert(!elseToken.IsDefault(), "'elseToken' must not be null.");
            Debug.Assert(elseToken.Kind == TokenKind.Else, "'elseToken' must have a TokenKind of 'Else'.");
            Debug.Assert(!body.IsDefault(), "'body' must not be null.");

            this.ElseToken = elseToken;
            this.Body = body;
            this.Body.Parent = this;
        }

        public Token ElseToken { get; private set; }

        public StatementBlockSyntax Body { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                yield return this.Body;
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.ElseToken.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.Body.Range.End;
                }
            }
        }
    }

    internal sealed class IfStatementSyntax : BaseStatementSyntax
    {
        public IfStatementSyntax(IfPartSyntax ifPart, IReadOnlyList<ElseIfPartSyntax> elseIfParts, ElsePartSyntax elsePartOpt, Token endIfToken)
        {
            Debug.Assert(!ifPart.IsDefault(), "'ifPart' must not be null.");
            Debug.Assert(!elseIfParts.IsDefault(), "'elseIfParts' must not be null.");
            Debug.Assert(!endIfToken.IsDefault(), "'endIfToken' must not be null.");
            Debug.Assert(endIfToken.Kind == TokenKind.EndIf, "'endIfToken' must have a TokenKind of 'EndIf'.");

            this.IfPart = ifPart;
            this.IfPart.Parent = this;
            this.ElseIfParts = elseIfParts;
            foreach (var child in this.ElseIfParts)
            {
                child.Parent = this;
            }

            this.ElsePartOpt = elsePartOpt;
            if (!this.ElsePartOpt.IsDefault())
            {
                this.ElsePartOpt.Parent = this;
            }

            this.EndIfToken = endIfToken;
        }

        public IfPartSyntax IfPart { get; private set; }

        public IReadOnlyList<ElseIfPartSyntax> ElseIfParts { get; private set; }

        public ElsePartSyntax ElsePartOpt { get; private set; }

        public Token EndIfToken { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                yield return this.IfPart;
                foreach (var child in this.ElseIfParts)
                {
                    yield return child;
                }

                if (!this.ElsePartOpt.IsDefault())
                {
                    yield return this.ElsePartOpt;
                }
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.IfPart.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.EndIfToken.Range.End;
                }
            }
        }
    }

    internal sealed class WhileStatementSyntax : BaseStatementSyntax
    {
        public WhileStatementSyntax(Token whileToken, BaseExpressionSyntax condition, StatementBlockSyntax body, Token endWhileToken)
        {
            Debug.Assert(!whileToken.IsDefault(), "'whileToken' must not be null.");
            Debug.Assert(whileToken.Kind == TokenKind.While, "'whileToken' must have a TokenKind of 'While'.");
            Debug.Assert(!condition.IsDefault(), "'condition' must not be null.");
            Debug.Assert(!body.IsDefault(), "'body' must not be null.");
            Debug.Assert(!endWhileToken.IsDefault(), "'endWhileToken' must not be null.");
            Debug.Assert(endWhileToken.Kind == TokenKind.EndWhile, "'endWhileToken' must have a TokenKind of 'EndWhile'.");

            this.WhileToken = whileToken;
            this.Condition = condition;
            this.Condition.Parent = this;
            this.Body = body;
            this.Body.Parent = this;
            this.EndWhileToken = endWhileToken;
        }

        public Token WhileToken { get; private set; }

        public BaseExpressionSyntax Condition { get; private set; }

        public StatementBlockSyntax Body { get; private set; }

        public Token EndWhileToken { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                yield return this.Condition;
                yield return this.Body;
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.WhileToken.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.EndWhileToken.Range.End;
                }
            }
        }
    }

    internal sealed class ForStepClauseSyntax : BaseSyntaxNode
    {
        public ForStepClauseSyntax(Token stepToken, BaseExpressionSyntax expression)
        {
            Debug.Assert(!stepToken.IsDefault(), "'stepToken' must not be null.");
            Debug.Assert(stepToken.Kind == TokenKind.Step, "'stepToken' must have a TokenKind of 'Step'.");
            Debug.Assert(!expression.IsDefault(), "'expression' must not be null.");

            this.StepToken = stepToken;
            this.Expression = expression;
            this.Expression.Parent = this;
        }

        public Token StepToken { get; private set; }

        public BaseExpressionSyntax Expression { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.StepToken.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.Expression.Range.End;
                }
            }
        }
    }

    internal sealed class ForStatementSyntax : BaseStatementSyntax
    {
        public ForStatementSyntax(Token forToken, Token identifierToken, Token equalToken, BaseExpressionSyntax fromExpression, Token toToken, BaseExpressionSyntax toExpression, ForStepClauseSyntax stepClauseOpt, StatementBlockSyntax body, Token endForToken)
        {
            Debug.Assert(!forToken.IsDefault(), "'forToken' must not be null.");
            Debug.Assert(forToken.Kind == TokenKind.For, "'forToken' must have a TokenKind of 'For'.");
            Debug.Assert(!identifierToken.IsDefault(), "'identifierToken' must not be null.");
            Debug.Assert(identifierToken.Kind == TokenKind.Identifier, "'identifierToken' must have a TokenKind of 'Identifier'.");
            Debug.Assert(!equalToken.IsDefault(), "'equalToken' must not be null.");
            Debug.Assert(equalToken.Kind == TokenKind.Equal, "'equalToken' must have a TokenKind of 'Equal'.");
            Debug.Assert(!fromExpression.IsDefault(), "'fromExpression' must not be null.");
            Debug.Assert(!toToken.IsDefault(), "'toToken' must not be null.");
            Debug.Assert(toToken.Kind == TokenKind.To, "'toToken' must have a TokenKind of 'To'.");
            Debug.Assert(!toExpression.IsDefault(), "'toExpression' must not be null.");
            Debug.Assert(!body.IsDefault(), "'body' must not be null.");
            Debug.Assert(!endForToken.IsDefault(), "'endForToken' must not be null.");
            Debug.Assert(endForToken.Kind == TokenKind.EndFor, "'endForToken' must have a TokenKind of 'EndFor'.");

            this.ForToken = forToken;
            this.IdentifierToken = identifierToken;
            this.EqualToken = equalToken;
            this.FromExpression = fromExpression;
            this.FromExpression.Parent = this;
            this.ToToken = toToken;
            this.ToExpression = toExpression;
            this.ToExpression.Parent = this;
            this.StepClauseOpt = stepClauseOpt;
            if (!this.StepClauseOpt.IsDefault())
            {
                this.StepClauseOpt.Parent = this;
            }

            this.Body = body;
            this.Body.Parent = this;
            this.EndForToken = endForToken;
        }

        public Token ForToken { get; private set; }

        public Token IdentifierToken { get; private set; }

        public Token EqualToken { get; private set; }

        public BaseExpressionSyntax FromExpression { get; private set; }

        public Token ToToken { get; private set; }

        public BaseExpressionSyntax ToExpression { get; private set; }

        public ForStepClauseSyntax StepClauseOpt { get; private set; }

        public StatementBlockSyntax Body { get; private set; }

        public Token EndForToken { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                yield return this.FromExpression;
                yield return this.ToExpression;
                if (!this.StepClauseOpt.IsDefault())
                {
                    yield return this.StepClauseOpt;
                }

                yield return this.Body;
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.ForToken.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.EndForToken.Range.End;
                }
            }
        }
    }

    internal sealed class LabelStatementSyntax : BaseStatementSyntax
    {
        public LabelStatementSyntax(Token labelToken, Token colonToken)
        {
            Debug.Assert(!labelToken.IsDefault(), "'labelToken' must not be null.");
            Debug.Assert(labelToken.Kind == TokenKind.Identifier, "'labelToken' must have a TokenKind of 'Identifier'.");
            Debug.Assert(!colonToken.IsDefault(), "'colonToken' must not be null.");
            Debug.Assert(colonToken.Kind == TokenKind.Colon, "'colonToken' must have a TokenKind of 'Colon'.");

            this.LabelToken = labelToken;
            this.ColonToken = colonToken;
        }

        public Token LabelToken { get; private set; }

        public Token ColonToken { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseSyntaxNode>();
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.LabelToken.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.ColonToken.Range.End;
                }
            }
        }
    }

    internal sealed class GoToStatementSyntax : BaseStatementSyntax
    {
        public GoToStatementSyntax(Token goToToken, Token labelToken)
        {
            Debug.Assert(!goToToken.IsDefault(), "'goToToken' must not be null.");
            Debug.Assert(goToToken.Kind == TokenKind.GoTo, "'goToToken' must have a TokenKind of 'GoTo'.");
            Debug.Assert(!labelToken.IsDefault(), "'labelToken' must not be null.");
            Debug.Assert(labelToken.Kind == TokenKind.Identifier, "'labelToken' must have a TokenKind of 'Identifier'.");

            this.GoToToken = goToToken;
            this.LabelToken = labelToken;
        }

        public Token GoToToken { get; private set; }

        public Token LabelToken { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseSyntaxNode>();
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.GoToToken.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.LabelToken.Range.End;
                }
            }
        }
    }

    internal sealed class UnrecognizedStatementSyntax : BaseStatementSyntax
    {
        public UnrecognizedStatementSyntax(Token unrecognizedToken)
        {
            Debug.Assert(!unrecognizedToken.IsDefault(), "'unrecognizedToken' must not be null.");

            this.UnrecognizedToken = unrecognizedToken;
        }

        public Token UnrecognizedToken { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseSyntaxNode>();
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.UnrecognizedToken.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.UnrecognizedToken.Range.End;
                }
            }
        }
    }

    internal sealed class ExpressionStatementSyntax : BaseStatementSyntax
    {
        public ExpressionStatementSyntax(BaseExpressionSyntax expression)
        {
            Debug.Assert(!expression.IsDefault(), "'expression' must not be null.");

            this.Expression = expression;
            this.Expression.Parent = this;
        }

        public BaseExpressionSyntax Expression { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.Expression.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.Expression.Range.End;
                }
            }
        }
    }

    internal sealed class CommentStatementSyntax : BaseStatementSyntax
    {
        public CommentStatementSyntax(Token commentToken)
        {
            Debug.Assert(!commentToken.IsDefault(), "'commentToken' must not be null.");
            Debug.Assert(commentToken.Kind == TokenKind.Comment, "'commentToken' must have a TokenKind of 'Comment'.");

            this.CommentToken = commentToken;
        }

        public Token CommentToken { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseSyntaxNode>();
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.CommentToken.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.CommentToken.Range.End;
                }
            }
        }
    }

    internal abstract class BaseExpressionSyntax : BaseSyntaxNode
    {
    }

    internal sealed class UnaryOperatorExpressionSyntax : BaseExpressionSyntax
    {
        public UnaryOperatorExpressionSyntax(Token operatorToken, BaseExpressionSyntax expression)
        {
            Debug.Assert(!operatorToken.IsDefault(), "'operatorToken' must not be null.");
            Debug.Assert(operatorToken.Kind == TokenKind.Minus, "'operatorToken' must have a TokenKind of 'Minus'.");
            Debug.Assert(!expression.IsDefault(), "'expression' must not be null.");

            this.OperatorToken = operatorToken;
            this.Expression = expression;
            this.Expression.Parent = this;
        }

        public Token OperatorToken { get; private set; }

        public BaseExpressionSyntax Expression { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.OperatorToken.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.Expression.Range.End;
                }
            }
        }
    }

    internal sealed class BinaryOperatorExpressionSyntax : BaseExpressionSyntax
    {
        public BinaryOperatorExpressionSyntax(BaseExpressionSyntax left, Token operatorToken, BaseExpressionSyntax right)
        {
            Debug.Assert(!left.IsDefault(), "'left' must not be null.");
            Debug.Assert(!operatorToken.IsDefault(), "'operatorToken' must not be null.");
            Debug.Assert(operatorToken.Kind == TokenKind.Equal || operatorToken.Kind == TokenKind.NotEqual || operatorToken.Kind == TokenKind.Plus || operatorToken.Kind == TokenKind.Minus || operatorToken.Kind == TokenKind.Multiply || operatorToken.Kind == TokenKind.Divide || operatorToken.Kind == TokenKind.Colon || operatorToken.Kind == TokenKind.LessThan || operatorToken.Kind == TokenKind.GreaterThan || operatorToken.Kind == TokenKind.LessThanOrEqual || operatorToken.Kind == TokenKind.GreaterThanOrEqual || operatorToken.Kind == TokenKind.And || operatorToken.Kind == TokenKind.Or, "'operatorToken' must have a TokenKind of 'Equal,NotEqual,Plus,Minus,Multiply,Divide,Colon,LessThan,GreaterThan,LessThanOrEqual,GreaterThanOrEqual,And,Or'.");
            Debug.Assert(!right.IsDefault(), "'right' must not be null.");

            this.Left = left;
            this.Left.Parent = this;
            this.OperatorToken = operatorToken;
            this.Right = right;
            this.Right.Parent = this;
        }

        public BaseExpressionSyntax Left { get; private set; }

        public Token OperatorToken { get; private set; }

        public BaseExpressionSyntax Right { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                yield return this.Left;
                yield return this.Right;
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.Left.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.Right.Range.End;
                }
            }
        }
    }

    internal sealed class ObjectAccessExpressionSyntax : BaseExpressionSyntax
    {
        public ObjectAccessExpressionSyntax(BaseExpressionSyntax baseExpression, Token dotToken, Token identifierToken)
        {
            Debug.Assert(!baseExpression.IsDefault(), "'baseExpression' must not be null.");
            Debug.Assert(!dotToken.IsDefault(), "'dotToken' must not be null.");
            Debug.Assert(dotToken.Kind == TokenKind.Dot, "'dotToken' must have a TokenKind of 'Dot'.");
            Debug.Assert(!identifierToken.IsDefault(), "'identifierToken' must not be null.");
            Debug.Assert(identifierToken.Kind == TokenKind.Identifier, "'identifierToken' must have a TokenKind of 'Identifier'.");

            this.BaseExpression = baseExpression;
            this.BaseExpression.Parent = this;
            this.DotToken = dotToken;
            this.IdentifierToken = identifierToken;
        }

        public BaseExpressionSyntax BaseExpression { get; private set; }

        public Token DotToken { get; private set; }

        public Token IdentifierToken { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                yield return this.BaseExpression;
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.BaseExpression.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.IdentifierToken.Range.End;
                }
            }
        }
    }

    internal sealed class ArrayAccessExpressionSyntax : BaseExpressionSyntax
    {
        public ArrayAccessExpressionSyntax(BaseExpressionSyntax baseExpression, Token leftBracketToken, BaseExpressionSyntax indexExpression, Token rightBracketToken)
        {
            Debug.Assert(!baseExpression.IsDefault(), "'baseExpression' must not be null.");
            Debug.Assert(!leftBracketToken.IsDefault(), "'leftBracketToken' must not be null.");
            Debug.Assert(leftBracketToken.Kind == TokenKind.LeftBracket, "'leftBracketToken' must have a TokenKind of 'LeftBracket'.");
            Debug.Assert(!indexExpression.IsDefault(), "'indexExpression' must not be null.");
            Debug.Assert(!rightBracketToken.IsDefault(), "'rightBracketToken' must not be null.");
            Debug.Assert(rightBracketToken.Kind == TokenKind.RightBracket, "'rightBracketToken' must have a TokenKind of 'RightBracket'.");

            this.BaseExpression = baseExpression;
            this.BaseExpression.Parent = this;
            this.LeftBracketToken = leftBracketToken;
            this.IndexExpression = indexExpression;
            this.IndexExpression.Parent = this;
            this.RightBracketToken = rightBracketToken;
        }

        public BaseExpressionSyntax BaseExpression { get; private set; }

        public Token LeftBracketToken { get; private set; }

        public BaseExpressionSyntax IndexExpression { get; private set; }

        public Token RightBracketToken { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                yield return this.BaseExpression;
                yield return this.IndexExpression;
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.BaseExpression.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.RightBracketToken.Range.End;
                }
            }
        }
    }

    internal sealed class ArgumentSyntax : BaseExpressionSyntax
    {
        public ArgumentSyntax(BaseExpressionSyntax expression, Token commaTokenOpt)
        {
            Debug.Assert(!expression.IsDefault(), "'expression' must not be null.");
            if (!commaTokenOpt.IsDefault())
            {
                Debug.Assert(commaTokenOpt.Kind == TokenKind.Comma, "'commaTokenOpt' must have a TokenKind of 'Comma'.");
            }

            this.Expression = expression;
            this.Expression.Parent = this;
            this.CommaTokenOpt = commaTokenOpt;
        }

        public BaseExpressionSyntax Expression { get; private set; }

        public Token CommaTokenOpt { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.Expression.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    if (!this.CommaTokenOpt.IsDefault())
                    {
                        return this.CommaTokenOpt.Range.End;
                    }

                    return this.Expression.Range.End;
                }
            }
        }
    }

    internal sealed class InvocationExpressionSyntax : BaseExpressionSyntax
    {
        public InvocationExpressionSyntax(BaseExpressionSyntax baseExpression, Token leftParenToken, IReadOnlyList<ArgumentSyntax> arguments, Token rightParenToken)
        {
            Debug.Assert(!baseExpression.IsDefault(), "'baseExpression' must not be null.");
            Debug.Assert(!leftParenToken.IsDefault(), "'leftParenToken' must not be null.");
            Debug.Assert(leftParenToken.Kind == TokenKind.LeftParen, "'leftParenToken' must have a TokenKind of 'LeftParen'.");
            Debug.Assert(!arguments.IsDefault(), "'arguments' must not be null.");
            Debug.Assert(!rightParenToken.IsDefault(), "'rightParenToken' must not be null.");
            Debug.Assert(rightParenToken.Kind == TokenKind.RightParen, "'rightParenToken' must have a TokenKind of 'RightParen'.");

            this.BaseExpression = baseExpression;
            this.BaseExpression.Parent = this;
            this.LeftParenToken = leftParenToken;
            this.Arguments = arguments;
            foreach (var child in this.Arguments)
            {
                child.Parent = this;
            }

            this.RightParenToken = rightParenToken;
        }

        public BaseExpressionSyntax BaseExpression { get; private set; }

        public Token LeftParenToken { get; private set; }

        public IReadOnlyList<ArgumentSyntax> Arguments { get; private set; }

        public Token RightParenToken { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                yield return this.BaseExpression;
                foreach (var child in this.Arguments)
                {
                    yield return child;
                }
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.BaseExpression.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.RightParenToken.Range.End;
                }
            }
        }
    }

    internal sealed class ParenthesisExpressionSyntax : BaseExpressionSyntax
    {
        public ParenthesisExpressionSyntax(Token leftParenToken, BaseExpressionSyntax expression, Token rightParenToken)
        {
            Debug.Assert(!leftParenToken.IsDefault(), "'leftParenToken' must not be null.");
            Debug.Assert(leftParenToken.Kind == TokenKind.LeftParen, "'leftParenToken' must have a TokenKind of 'LeftParen'.");
            Debug.Assert(!expression.IsDefault(), "'expression' must not be null.");
            Debug.Assert(!rightParenToken.IsDefault(), "'rightParenToken' must not be null.");
            Debug.Assert(rightParenToken.Kind == TokenKind.RightParen, "'rightParenToken' must have a TokenKind of 'RightParen'.");

            this.LeftParenToken = leftParenToken;
            this.Expression = expression;
            this.Expression.Parent = this;
            this.RightParenToken = rightParenToken;
        }

        public Token LeftParenToken { get; private set; }

        public BaseExpressionSyntax Expression { get; private set; }

        public Token RightParenToken { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.LeftParenToken.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.RightParenToken.Range.End;
                }
            }
        }
    }

    internal sealed class IdentifierExpressionSyntax : BaseExpressionSyntax
    {
        public IdentifierExpressionSyntax(Token identifierToken)
        {
            Debug.Assert(!identifierToken.IsDefault(), "'identifierToken' must not be null.");
            Debug.Assert(identifierToken.Kind == TokenKind.Identifier, "'identifierToken' must have a TokenKind of 'Identifier'.");

            this.IdentifierToken = identifierToken;
        }

        public Token IdentifierToken { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseSyntaxNode>();
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.IdentifierToken.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.IdentifierToken.Range.End;
                }
            }
        }
    }

    internal sealed class StringLiteralExpressionSyntax : BaseExpressionSyntax
    {
        public StringLiteralExpressionSyntax(Token stringToken)
        {
            Debug.Assert(!stringToken.IsDefault(), "'stringToken' must not be null.");
            Debug.Assert(stringToken.Kind == TokenKind.StringLiteral, "'stringToken' must have a TokenKind of 'StringLiteral'.");

            this.StringToken = stringToken;
        }

        public Token StringToken { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseSyntaxNode>();
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.StringToken.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.StringToken.Range.End;
                }
            }
        }
    }

    internal sealed class NumberLiteralExpressionSyntax : BaseExpressionSyntax
    {
        public NumberLiteralExpressionSyntax(Token numberToken)
        {
            Debug.Assert(!numberToken.IsDefault(), "'numberToken' must not be null.");
            Debug.Assert(numberToken.Kind == TokenKind.NumberLiteral, "'numberToken' must have a TokenKind of 'NumberLiteral'.");

            this.NumberToken = numberToken;
        }

        public Token NumberToken { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseSyntaxNode>();
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.NumberToken.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.NumberToken.Range.End;
                }
            }
        }
    }

    internal sealed class UnrecognizedExpressionSyntax : BaseExpressionSyntax
    {
        public UnrecognizedExpressionSyntax(Token unrecognizedToken)
        {
            Debug.Assert(!unrecognizedToken.IsDefault(), "'unrecognizedToken' must not be null.");

            this.UnrecognizedToken = unrecognizedToken;
        }

        public Token UnrecognizedToken { get; private set; }

        public override IEnumerable<BaseSyntaxNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseSyntaxNode>();
            }
        }

        public override TextRange Range
        {
            get
            {
                return (calculateStart(), calculateEnd());

                TextPosition calculateStart()
                {
                    return this.UnrecognizedToken.Range.Start;
                }

                TextPosition calculateEnd()
                {
                    return this.UnrecognizedToken.Range.End;
                }
            }
        }
    }
}
