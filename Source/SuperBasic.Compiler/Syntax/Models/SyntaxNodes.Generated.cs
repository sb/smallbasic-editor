// <copyright file="SyntaxNodes.Generated.cs" company="2018 Omar Tawfik">
// Copyright (c) 2018 Omar Tawfik. All rights reserved. Licensed under the MIT License. See LICENSE file in the project root for license information.
// </copyright>

/// <summary>
/// This file is auto-generated by a build task. It shouldn't be edited by hand.
/// </summary>
namespace SuperBasic.Compiler.Syntax
{
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Diagnostics;
    using System.Linq;

    internal abstract class BaseStatementSyntax : BaseSyntax
    {
    }

    internal abstract class BaseCommandSyntax : BaseSyntax
    {
    }

    internal abstract class BaseExpressionSyntax : BaseSyntax
    {
    }

    internal sealed class ParseTreeSyntax : BaseSyntax
    {
        public ParseTreeSyntax(StatementBlockSyntax mainModule, ImmutableArray<SubModuleDeclarationSyntax> subModules)
        {
            Debug.Assert(!ReferenceEquals(mainModule, null), "'mainModule' must not be null.");
            Debug.Assert(!ReferenceEquals(subModules, null), "'subModules' must not be null.");

            this.MainModule = mainModule;
            this.SubModules = subModules;
        }

        public StatementBlockSyntax MainModule { get; private set; }

        public ImmutableArray<SubModuleDeclarationSyntax> SubModules { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.MainModule;

                foreach (var child in this.SubModules)
                {
                    yield return child;
                }
            }
        }
    }

    internal sealed class SubModuleDeclarationSyntax : BaseSyntax
    {
        public SubModuleDeclarationSyntax(SubCommandSyntax subCommand, StatementBlockSyntax statements, EndSubCommandSyntax endSubCommand)
        {
            Debug.Assert(!ReferenceEquals(subCommand, null), "'subCommand' must not be null.");
            Debug.Assert(!ReferenceEquals(statements, null), "'statements' must not be null.");
            Debug.Assert(!ReferenceEquals(endSubCommand, null), "'endSubCommand' must not be null.");

            this.SubCommand = subCommand;
            this.Statements = statements;
            this.EndSubCommand = endSubCommand;
        }

        public SubCommandSyntax SubCommand { get; private set; }

        public StatementBlockSyntax Statements { get; private set; }

        public EndSubCommandSyntax EndSubCommand { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.SubCommand;
                yield return this.Statements;
                yield return this.EndSubCommand;
            }
        }
    }

    internal sealed class StatementBlockSyntax : BaseSyntax
    {
        public StatementBlockSyntax(ImmutableArray<BaseStatementSyntax> statements)
        {
            Debug.Assert(!ReferenceEquals(statements, null), "'statements' must not be null.");

            this.Statements = statements;
        }

        public ImmutableArray<BaseStatementSyntax> Statements { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                foreach (var child in this.Statements)
                {
                    yield return child;
                }
            }
        }
    }

    internal sealed class IfHeaderSyntax : BaseSyntax
    {
        public IfHeaderSyntax(IfCommandSyntax ifCommand, StatementBlockSyntax statements)
        {
            Debug.Assert(!ReferenceEquals(ifCommand, null), "'ifCommand' must not be null.");
            Debug.Assert(!ReferenceEquals(statements, null), "'statements' must not be null.");

            this.IfCommand = ifCommand;
            this.Statements = statements;
        }

        public IfCommandSyntax IfCommand { get; private set; }

        public StatementBlockSyntax Statements { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.IfCommand;
                yield return this.Statements;
            }
        }
    }

    internal sealed class ElseIfHeaderSyntax : BaseSyntax
    {
        public ElseIfHeaderSyntax(ElseIfCommandSyntax elseIfCommand, StatementBlockSyntax statements)
        {
            Debug.Assert(!ReferenceEquals(elseIfCommand, null), "'elseIfCommand' must not be null.");
            Debug.Assert(!ReferenceEquals(statements, null), "'statements' must not be null.");

            this.ElseIfCommand = elseIfCommand;
            this.Statements = statements;
        }

        public ElseIfCommandSyntax ElseIfCommand { get; private set; }

        public StatementBlockSyntax Statements { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.ElseIfCommand;
                yield return this.Statements;
            }
        }
    }

    internal sealed class ElseHeaderSyntax : BaseSyntax
    {
        public ElseHeaderSyntax(ElseCommandSyntax elseCommand, StatementBlockSyntax statements)
        {
            Debug.Assert(!ReferenceEquals(elseCommand, null), "'elseCommand' must not be null.");
            Debug.Assert(!ReferenceEquals(statements, null), "'statements' must not be null.");

            this.ElseCommand = elseCommand;
            this.Statements = statements;
        }

        public ElseCommandSyntax ElseCommand { get; private set; }

        public StatementBlockSyntax Statements { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.ElseCommand;
                yield return this.Statements;
            }
        }
    }

    internal sealed class IfStatementSyntax : BaseStatementSyntax
    {
        public IfStatementSyntax(IfHeaderSyntax ifPart, ImmutableArray<ElseIfHeaderSyntax> elseIfParts, ElseHeaderSyntax elsePartOpt, EndIfCommandSyntax endIfCommand)
        {
            Debug.Assert(!ReferenceEquals(ifPart, null), "'ifPart' must not be null.");
            Debug.Assert(!ReferenceEquals(elseIfParts, null), "'elseIfParts' must not be null.");
            Debug.Assert(!ReferenceEquals(endIfCommand, null), "'endIfCommand' must not be null.");

            this.IfPart = ifPart;
            this.ElseIfParts = elseIfParts;
            this.ElsePartOpt = elsePartOpt;
            this.EndIfCommand = endIfCommand;
        }

        public IfHeaderSyntax IfPart { get; private set; }

        public ImmutableArray<ElseIfHeaderSyntax> ElseIfParts { get; private set; }

        public ElseHeaderSyntax ElsePartOpt { get; private set; }

        public EndIfCommandSyntax EndIfCommand { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.IfPart;

                foreach (var child in this.ElseIfParts)
                {
                    yield return child;
                }

                if (!ReferenceEquals(this.ElsePartOpt, null))
                {
                    yield return this.ElsePartOpt;
                }

                yield return this.EndIfCommand;
            }
        }
    }

    internal sealed class WhileStatementSyntax : BaseStatementSyntax
    {
        public WhileStatementSyntax(WhileCommandSyntax whileCommand, StatementBlockSyntax statements, EndWhileCommandSyntax endWhileCommand)
        {
            Debug.Assert(!ReferenceEquals(whileCommand, null), "'whileCommand' must not be null.");
            Debug.Assert(!ReferenceEquals(statements, null), "'statements' must not be null.");
            Debug.Assert(!ReferenceEquals(endWhileCommand, null), "'endWhileCommand' must not be null.");

            this.WhileCommand = whileCommand;
            this.Statements = statements;
            this.EndWhileCommand = endWhileCommand;
        }

        public WhileCommandSyntax WhileCommand { get; private set; }

        public StatementBlockSyntax Statements { get; private set; }

        public EndWhileCommandSyntax EndWhileCommand { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.WhileCommand;
                yield return this.Statements;
                yield return this.EndWhileCommand;
            }
        }
    }

    internal sealed class ForStatementSyntax : BaseStatementSyntax
    {
        public ForStatementSyntax(ForCommandSyntax forCommand, StatementBlockSyntax statements, EndForCommandSyntax endForCommand)
        {
            Debug.Assert(!ReferenceEquals(forCommand, null), "'forCommand' must not be null.");
            Debug.Assert(!ReferenceEquals(statements, null), "'statements' must not be null.");
            Debug.Assert(!ReferenceEquals(endForCommand, null), "'endForCommand' must not be null.");

            this.ForCommand = forCommand;
            this.Statements = statements;
            this.EndForCommand = endForCommand;
        }

        public ForCommandSyntax ForCommand { get; private set; }

        public StatementBlockSyntax Statements { get; private set; }

        public EndForCommandSyntax EndForCommand { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.ForCommand;
                yield return this.Statements;
                yield return this.EndForCommand;
            }
        }
    }

    internal sealed class IfCommandSyntax : BaseCommandSyntax
    {
        public IfCommandSyntax(TokenSyntax ifToken, BaseExpressionSyntax expression, TokenSyntax thenToken)
        {
            Debug.Assert(!ReferenceEquals(ifToken, null), "'ifToken' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");
            Debug.Assert(!ReferenceEquals(thenToken, null), "'thenToken' must not be null.");

            this.IfToken = ifToken;
            this.Expression = expression;
            this.ThenToken = thenToken;
        }

        public TokenSyntax IfToken { get; private set; }

        public BaseExpressionSyntax Expression { get; private set; }

        public TokenSyntax ThenToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.IfToken;
                yield return this.Expression;
                yield return this.ThenToken;
            }
        }
    }

    internal sealed class ElseIfCommandSyntax : BaseCommandSyntax
    {
        public ElseIfCommandSyntax(TokenSyntax elseIfToken, BaseExpressionSyntax expression, TokenSyntax thenToken)
        {
            Debug.Assert(!ReferenceEquals(elseIfToken, null), "'elseIfToken' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");
            Debug.Assert(!ReferenceEquals(thenToken, null), "'thenToken' must not be null.");

            this.ElseIfToken = elseIfToken;
            this.Expression = expression;
            this.ThenToken = thenToken;
        }

        public TokenSyntax ElseIfToken { get; private set; }

        public BaseExpressionSyntax Expression { get; private set; }

        public TokenSyntax ThenToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.ElseIfToken;
                yield return this.Expression;
                yield return this.ThenToken;
            }
        }
    }

    internal sealed class ElseCommandSyntax : BaseCommandSyntax
    {
        public ElseCommandSyntax(TokenSyntax elseToken)
        {
            Debug.Assert(!ReferenceEquals(elseToken, null), "'elseToken' must not be null.");

            this.ElseToken = elseToken;
        }

        public TokenSyntax ElseToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.ElseToken;
            }
        }
    }

    internal sealed class EndIfCommandSyntax : BaseCommandSyntax
    {
        public EndIfCommandSyntax(TokenSyntax endIfToken)
        {
            Debug.Assert(!ReferenceEquals(endIfToken, null), "'endIfToken' must not be null.");

            this.EndIfToken = endIfToken;
        }

        public TokenSyntax EndIfToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.EndIfToken;
            }
        }
    }

    internal sealed class ForStepClauseSyntax : BaseSyntax
    {
        public ForStepClauseSyntax(TokenSyntax stepToken, BaseExpressionSyntax expression)
        {
            Debug.Assert(!ReferenceEquals(stepToken, null), "'stepToken' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");

            this.StepToken = stepToken;
            this.Expression = expression;
        }

        public TokenSyntax StepToken { get; private set; }

        public BaseExpressionSyntax Expression { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.StepToken;
                yield return this.Expression;
            }
        }
    }

    internal sealed class ForCommandSyntax : BaseCommandSyntax
    {
        public ForCommandSyntax(TokenSyntax forToken, TokenSyntax identifierToken, TokenSyntax equalToken, BaseExpressionSyntax fromExpression, TokenSyntax toToken, ForStepClauseSyntax stepClauseOpt)
        {
            Debug.Assert(!ReferenceEquals(forToken, null), "'forToken' must not be null.");
            Debug.Assert(!ReferenceEquals(identifierToken, null), "'identifierToken' must not be null.");
            Debug.Assert(!ReferenceEquals(equalToken, null), "'equalToken' must not be null.");
            Debug.Assert(!ReferenceEquals(fromExpression, null), "'fromExpression' must not be null.");
            Debug.Assert(!ReferenceEquals(toToken, null), "'toToken' must not be null.");

            this.ForToken = forToken;
            this.IdentifierToken = identifierToken;
            this.EqualToken = equalToken;
            this.FromExpression = fromExpression;
            this.ToToken = toToken;
            this.StepClauseOpt = stepClauseOpt;
        }

        public TokenSyntax ForToken { get; private set; }

        public TokenSyntax IdentifierToken { get; private set; }

        public TokenSyntax EqualToken { get; private set; }

        public BaseExpressionSyntax FromExpression { get; private set; }

        public TokenSyntax ToToken { get; private set; }

        public ForStepClauseSyntax StepClauseOpt { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.ForToken;
                yield return this.IdentifierToken;
                yield return this.EqualToken;
                yield return this.FromExpression;
                yield return this.ToToken;

                if (!ReferenceEquals(this.StepClauseOpt, null))
                {
                    yield return this.StepClauseOpt;
                }
            }
        }
    }

    internal sealed class EndForCommandSyntax : BaseCommandSyntax
    {
        public EndForCommandSyntax(TokenSyntax endForToken)
        {
            Debug.Assert(!ReferenceEquals(endForToken, null), "'endForToken' must not be null.");

            this.EndForToken = endForToken;
        }

        public TokenSyntax EndForToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.EndForToken;
            }
        }
    }

    internal sealed class WhileCommandSyntax : BaseCommandSyntax
    {
        public WhileCommandSyntax(TokenSyntax whileToken, BaseExpressionSyntax expressionExpression)
        {
            Debug.Assert(!ReferenceEquals(whileToken, null), "'whileToken' must not be null.");
            Debug.Assert(!ReferenceEquals(expressionExpression, null), "'expressionExpression' must not be null.");

            this.WhileToken = whileToken;
            this.ExpressionExpression = expressionExpression;
        }

        public TokenSyntax WhileToken { get; private set; }

        public BaseExpressionSyntax ExpressionExpression { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.WhileToken;
                yield return this.ExpressionExpression;
            }
        }
    }

    internal sealed class EndWhileCommandSyntax : BaseCommandSyntax
    {
        public EndWhileCommandSyntax(TokenSyntax endWhileToken)
        {
            Debug.Assert(!ReferenceEquals(endWhileToken, null), "'endWhileToken' must not be null.");

            this.EndWhileToken = endWhileToken;
        }

        public TokenSyntax EndWhileToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.EndWhileToken;
            }
        }
    }

    internal sealed class LabelCommandSyntax : BaseCommandSyntax
    {
        public LabelCommandSyntax(TokenSyntax labelToken, TokenSyntax colonToken)
        {
            Debug.Assert(!ReferenceEquals(labelToken, null), "'labelToken' must not be null.");
            Debug.Assert(!ReferenceEquals(colonToken, null), "'colonToken' must not be null.");

            this.LabelToken = labelToken;
            this.ColonToken = colonToken;
        }

        public TokenSyntax LabelToken { get; private set; }

        public TokenSyntax ColonToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.LabelToken;
                yield return this.ColonToken;
            }
        }
    }

    internal sealed class GoToCommandSyntax : BaseCommandSyntax
    {
        public GoToCommandSyntax(TokenSyntax goToToken, TokenSyntax labelToken)
        {
            Debug.Assert(!ReferenceEquals(goToToken, null), "'goToToken' must not be null.");
            Debug.Assert(!ReferenceEquals(labelToken, null), "'labelToken' must not be null.");

            this.GoToToken = goToToken;
            this.LabelToken = labelToken;
        }

        public TokenSyntax GoToToken { get; private set; }

        public TokenSyntax LabelToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.GoToToken;
                yield return this.LabelToken;
            }
        }
    }

    internal sealed class SubCommandSyntax : BaseCommandSyntax
    {
        public SubCommandSyntax(TokenSyntax subToken, TokenSyntax nameToken)
        {
            Debug.Assert(!ReferenceEquals(subToken, null), "'subToken' must not be null.");
            Debug.Assert(!ReferenceEquals(nameToken, null), "'nameToken' must not be null.");

            this.SubToken = subToken;
            this.NameToken = nameToken;
        }

        public TokenSyntax SubToken { get; private set; }

        public TokenSyntax NameToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.SubToken;
                yield return this.NameToken;
            }
        }
    }

    internal sealed class EndSubCommandSyntax : BaseCommandSyntax
    {
        public EndSubCommandSyntax(TokenSyntax endSubToken)
        {
            Debug.Assert(!ReferenceEquals(endSubToken, null), "'endSubToken' must not be null.");

            this.EndSubToken = endSubToken;
        }

        public TokenSyntax EndSubToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.EndSubToken;
            }
        }
    }

    internal sealed class CommentCommandSyntax : BaseCommandSyntax
    {
        public CommentCommandSyntax(TokenSyntax commentToken)
        {
            Debug.Assert(!ReferenceEquals(commentToken, null), "'commentToken' must not be null.");

            this.CommentToken = commentToken;
        }

        public TokenSyntax CommentToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.CommentToken;
            }
        }
    }

    internal sealed class ExpressionCommandSyntax : BaseCommandSyntax
    {
        public ExpressionCommandSyntax(BaseExpressionSyntax expression)
        {
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");

            this.Expression = expression;
        }

        public BaseExpressionSyntax Expression { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.Expression;
            }
        }
    }

    internal sealed class UnaryOperatorExpressionSyntax : BaseExpressionSyntax
    {
        public UnaryOperatorExpressionSyntax(TokenSyntax operatorToken, BaseExpressionSyntax expression)
        {
            Debug.Assert(!ReferenceEquals(operatorToken, null), "'operatorToken' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");

            this.OperatorToken = operatorToken;
            this.Expression = expression;
        }

        public TokenSyntax OperatorToken { get; private set; }

        public BaseExpressionSyntax Expression { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.OperatorToken;
                yield return this.Expression;
            }
        }
    }

    internal sealed class BinaryOperatorExpressionSyntax : BaseExpressionSyntax
    {
        public BinaryOperatorExpressionSyntax(BaseExpressionSyntax leftExpression, TokenSyntax operatorToken, BaseExpressionSyntax rightExpression)
        {
            Debug.Assert(!ReferenceEquals(leftExpression, null), "'leftExpression' must not be null.");
            Debug.Assert(!ReferenceEquals(operatorToken, null), "'operatorToken' must not be null.");
            Debug.Assert(!ReferenceEquals(rightExpression, null), "'rightExpression' must not be null.");

            this.LeftExpression = leftExpression;
            this.OperatorToken = operatorToken;
            this.RightExpression = rightExpression;
        }

        public BaseExpressionSyntax LeftExpression { get; private set; }

        public TokenSyntax OperatorToken { get; private set; }

        public BaseExpressionSyntax RightExpression { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.LeftExpression;
                yield return this.OperatorToken;
                yield return this.RightExpression;
            }
        }
    }

    internal sealed class ObjectAccessExpressionSyntax : BaseExpressionSyntax
    {
        public ObjectAccessExpressionSyntax(BaseExpressionSyntax baseExpression, TokenSyntax dotToken, TokenSyntax identifierToken)
        {
            Debug.Assert(!ReferenceEquals(baseExpression, null), "'baseExpression' must not be null.");
            Debug.Assert(!ReferenceEquals(dotToken, null), "'dotToken' must not be null.");
            Debug.Assert(!ReferenceEquals(identifierToken, null), "'identifierToken' must not be null.");

            this.BaseExpression = baseExpression;
            this.DotToken = dotToken;
            this.IdentifierToken = identifierToken;
        }

        public BaseExpressionSyntax BaseExpression { get; private set; }

        public TokenSyntax DotToken { get; private set; }

        public TokenSyntax IdentifierToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.BaseExpression;
                yield return this.DotToken;
                yield return this.IdentifierToken;
            }
        }
    }

    internal sealed class ArrayAccessExpressionSyntax : BaseExpressionSyntax
    {
        public ArrayAccessExpressionSyntax(BaseExpressionSyntax baseExpression, TokenSyntax leftBracketToken, BaseExpressionSyntax indexExpression, TokenSyntax rightBracketToken)
        {
            Debug.Assert(!ReferenceEquals(baseExpression, null), "'baseExpression' must not be null.");
            Debug.Assert(!ReferenceEquals(leftBracketToken, null), "'leftBracketToken' must not be null.");
            Debug.Assert(!ReferenceEquals(indexExpression, null), "'indexExpression' must not be null.");
            Debug.Assert(!ReferenceEquals(rightBracketToken, null), "'rightBracketToken' must not be null.");

            this.BaseExpression = baseExpression;
            this.LeftBracketToken = leftBracketToken;
            this.IndexExpression = indexExpression;
            this.RightBracketToken = rightBracketToken;
        }

        public BaseExpressionSyntax BaseExpression { get; private set; }

        public TokenSyntax LeftBracketToken { get; private set; }

        public BaseExpressionSyntax IndexExpression { get; private set; }

        public TokenSyntax RightBracketToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.BaseExpression;
                yield return this.LeftBracketToken;
                yield return this.IndexExpression;
                yield return this.RightBracketToken;
            }
        }
    }

    internal sealed class ArgumentSyntax : BaseExpressionSyntax
    {
        public ArgumentSyntax(BaseExpressionSyntax expression, TokenSyntax commaTokenOpt)
        {
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");

            this.Expression = expression;
            this.CommaTokenOpt = commaTokenOpt;
        }

        public BaseExpressionSyntax Expression { get; private set; }

        public TokenSyntax CommaTokenOpt { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.Expression;

                if (!ReferenceEquals(this.CommaTokenOpt, null))
                {
                    yield return this.CommaTokenOpt;
                }
            }
        }
    }

    internal sealed class InvocationExpressionSyntax : BaseExpressionSyntax
    {
        public InvocationExpressionSyntax(BaseExpressionSyntax baseExpression, TokenSyntax leftParenToken, ImmutableArray<ArgumentSyntax> arguments, TokenSyntax rightParenToken)
        {
            Debug.Assert(!ReferenceEquals(baseExpression, null), "'baseExpression' must not be null.");
            Debug.Assert(!ReferenceEquals(leftParenToken, null), "'leftParenToken' must not be null.");
            Debug.Assert(!ReferenceEquals(arguments, null), "'arguments' must not be null.");
            Debug.Assert(!ReferenceEquals(rightParenToken, null), "'rightParenToken' must not be null.");

            this.BaseExpression = baseExpression;
            this.LeftParenToken = leftParenToken;
            this.Arguments = arguments;
            this.RightParenToken = rightParenToken;
        }

        public BaseExpressionSyntax BaseExpression { get; private set; }

        public TokenSyntax LeftParenToken { get; private set; }

        public ImmutableArray<ArgumentSyntax> Arguments { get; private set; }

        public TokenSyntax RightParenToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.BaseExpression;
                yield return this.LeftParenToken;

                foreach (var child in this.Arguments)
                {
                    yield return child;
                }

                yield return this.RightParenToken;
            }
        }
    }

    internal sealed class ParenthesisExpressionSyntax : BaseExpressionSyntax
    {
        public ParenthesisExpressionSyntax(TokenSyntax leftParenToken, BaseExpressionSyntax expression, TokenSyntax rightParenToken)
        {
            Debug.Assert(!ReferenceEquals(leftParenToken, null), "'leftParenToken' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");
            Debug.Assert(!ReferenceEquals(rightParenToken, null), "'rightParenToken' must not be null.");

            this.LeftParenToken = leftParenToken;
            this.Expression = expression;
            this.RightParenToken = rightParenToken;
        }

        public TokenSyntax LeftParenToken { get; private set; }

        public BaseExpressionSyntax Expression { get; private set; }

        public TokenSyntax RightParenToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.LeftParenToken;
                yield return this.Expression;
                yield return this.RightParenToken;
            }
        }
    }

    internal sealed class IdentifierExpressionSyntax : BaseExpressionSyntax
    {
        public IdentifierExpressionSyntax(TokenSyntax identifierToken)
        {
            Debug.Assert(!ReferenceEquals(identifierToken, null), "'identifierToken' must not be null.");

            this.IdentifierToken = identifierToken;
        }

        public TokenSyntax IdentifierToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.IdentifierToken;
            }
        }
    }

    internal sealed class StringLiteralExpressionSyntax : BaseExpressionSyntax
    {
        public StringLiteralExpressionSyntax(TokenSyntax stringToken)
        {
            Debug.Assert(!ReferenceEquals(stringToken, null), "'stringToken' must not be null.");

            this.StringToken = stringToken;
        }

        public TokenSyntax StringToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.StringToken;
            }
        }
    }

    internal sealed class NumberLiteralExpressionSyntax : BaseExpressionSyntax
    {
        public NumberLiteralExpressionSyntax(TokenSyntax numberToken)
        {
            Debug.Assert(!ReferenceEquals(numberToken, null), "'numberToken' must not be null.");

            this.NumberToken = numberToken;
        }

        public TokenSyntax NumberToken { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                yield return this.NumberToken;
            }
        }
    }

    internal sealed class TokenSyntax : BaseSyntax
    {
        public TokenSyntax(Token token)
        {
            Debug.Assert(!ReferenceEquals(token, null), "'token' must not be null.");

            this.Token = token;
        }

        public Token Token { get; private set; }

        public override IEnumerable<BaseSyntax> Children
        {
            get
            {
                return Enumerable.Empty<BaseSyntax>();
            }
        }
    }
}
